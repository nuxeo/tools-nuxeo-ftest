var outDir = "out.dir";

Selenium.prototype.doRetrieveTestFolderPath = function() {
    storedVars['testfolderpath'] = "/path/to/project-ear/ftest/selenium/data/";
};

// helper method to store current year/month/day
Selenium.prototype.doRetrieveCurrentDateInfo = function() {
    var date = new Date();
    storedVars['currentYear'] = date.getFullYear();
    var m = date.getMonth() + 1;
    storedVars['currentMonth'] = (m < 10) ? '0' + m : m;
    var d = date.getDate();
    storedVars['currentDay'] = (d < 10) ? '0' + d : d;
};

// NXBT-663: override isTextPresent to detect heavy pages
Selenium.prototype.isTextPresent = function(pattern) {
    /**
   * Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.
   * @param pattern a <a href="#patterns">pattern</a> to match with the text of the page
   * @return boolean true if the pattern matches the text, false otherwise
   */
    var allText = this.browserbot.bodyText();

    var patternMatcher = new PatternMatcher(pattern);
    if (patternMatcher.strategy == PatternMatcher.strategies.glob) {
            if (pattern.indexOf("glob:")==0) {
                    pattern = pattern.substring("glob:".length); // strip off "glob:"
                }
        patternMatcher.matcher = new PatternMatcher.strategies.globContains(pattern);
    }
    else if (patternMatcher.strategy == PatternMatcher.strategies.exact) {
                pattern = pattern.substring("exact:".length); // strip off "exact:"
        LOG.info("isTextPresent with pattern matcher, textLength=" + allText.length);
        if (allText.length > 2500) {
          LOG.info("isTextPresent: page is too heavy");
        }
        return allText.indexOf(pattern) != -1;
    }
    LOG.info("isTextPresent, textLength=" + allText.length);
    if (allText.length > 2500) {
      LOG.info("isTextPresent: page is too heavy");
    }
    return patternMatcher.matches(allText);
};

// override default method to make sure privilege to type file path is enabled
Selenium.prototype.doOriginalType = Selenium.prototype.doType;

// override buggy doTypeKeys method
// FIXME: need to document what's buggy in case it's fixed in more recent versions
Selenium.prototype.doTypeKeys = function(locator, value) {
    // send key events (in the correct order unlike the api)
    var keys = new String(value).split("");
    for (var i = 0; i < keys.length; i++) {
      var c = keys[i];
      this.doKeyDown(locator, c);
      this.doKeyPress(locator, c);
      this.doKeyUp(locator, c);
    }

    // also set the correct text in the element
    try {
        this.doOriginalType(locator, value);
    } catch(err) {
        // this wasn't a text element
    }

};

/**
 * Registers with the a4j library to record when an Ajax request
 * finishes.
 *
 * Call this after the most recent page load but before any Ajax requests.
 *
 * Once you've called this for a page, you should call waitForA4jRequest at
 * every opportunity, to make sure the A4jRequestFinished flag is consumed.
 */
Selenium.prototype.doWatchA4jRequests = function() {
  var testWindow = selenium.browserbot.getCurrentWindow();
  testWindow.A4J.AJAX.startTest();
}

/**
 * If you've set up with watchA4jRequests, this routine will wait until
 * an Ajax request has finished and then return.
 */
Selenium.prototype.doWaitForA4jRequest = function(timeout) {
  return Selenium.decorateFunctionWithTimeout(function() {
    var testWindow = selenium.browserbot.getCurrentWindow();
    if (testWindow.A4J.AJAX.isTestFinished() == true) {
        return true;
    }
    return false;
  }, timeout);
}


// wait for jquery and/or prototype calls
Selenium.prototype.doWaitForJSQueries = function(timeout) {
  return Selenium.decorateFunctionWithTimeout(function() {
    var testWindow = selenium.browserbot.getCurrentWindow();
    if (testWindow.jQuery.active == 0 && testWindow.Ajax.activeRequestCount == 0) {
      return true;
    }
    return false;
  }, timeout);
}

/**
 * Function that waits for opensocial gadgets to be loaded.
 * Assumes frame name starts with "open-social" and will display a div with id
 * "content".
 * Accepts one or more mandatory element id(s), separated by ',',
 * with content to check, and timeout.
 */
Selenium.prototype.doWaitForOpensocialGadgetsToLoad = function(mandatoryElementIds, timeout) {
  var framesLoadedPredicate = function () {
    var testWindow = selenium.browserbot.getCurrentWindow();
    if (testWindow.document.getElementById("gwtContainerDiv") === null) {
      // there is no OpenSocial container
      return true;
    }

    var foundOneGadgetFrame = false;
    if (testWindow.frames && testWindow.frames.length && testWindow.frames.length > 0) {
      for (var i = 0; i < testWindow.frames.length; i++) {
        LOG.debug("Selected frame: " + testWindow.frames[i].name);
        if (testWindow.frames[i].name && testWindow.frames[i].name.match("^open-social")=="open-social") {
          foundOneGadgetFrame = true;
          selenium.browserbot.selectFrame("index="+i);
          var testFrame = selenium.browserbot.getCurrentWindow();
          // wait for frame to be loaded
          var loaded = false;
          var mandatoryElementIdList = mandatoryElementIds.split(",");
          for(var j=0; j < mandatoryElementIdList.length ; j++){
            if (testFrame.document.getElementById(mandatoryElementIdList[j])) {
              var content = this.getText(testFrame.document.getElementById(mandatoryElementIdList[j]));
              if (content) {
                loaded = true;
                break;
              }
            }
          }
          if (!loaded) {
            // go back to original window
            selenium.browserbot.selectWindow();
            return false;
          }
          LOG.debug("Loaded frame: " + testWindow.frames[i].name);
          // go back to original window to iterate over frames
          selenium.browserbot.selectWindow();
        }
      }
      if (!foundOneGadgetFrame) {
        LOG.debug("no gadget frames present yet");
        return false;
      }
    } else {
      LOG.debug("no frames present yet");
      return false;
    }
    return true;
  };

  return Selenium.decorateFunctionWithTimeout(framesLoadedPredicate, timeout);
}

/**
 * Function that selects the frame for a given gadget name.
 * Assumes frame css classes contains a class which is the gadget name.
 *
 * Do not fail if there is no frame for the given gadget name in the page.
 */
Selenium.prototype.doSelectOpenSocialGadgetFrame = function(gadgetName) {
  var testWindow = selenium.browserbot.getCurrentWindow();
  if (testWindow.frames && testWindow.frames.length && testWindow.frames.length > 0) {
   for (var i = 0; i < testWindow.frames.length; i++) {
     var frame = testWindow.document.getElementById(testWindow.frames[i].name);
     if (typeof frame !== 'undefined' && frame !== null) {
       var styleClass = frame.getAttribute("class");
       if (styleClass !== null && styleClass.indexOf(gadgetName) != -1) {
         return selenium.browserbot.selectFrame(testWindow.frames[i].name);
       }
     }
   }
  }
  return;
}

/**
 * Select2 extensions.
 */
Selenium.prototype.doSelect2Type = function(cssSelector,value) {
  LOG.debug("doSelect2Type begin");
  if (selenium.isElementPresent(cssSelector + ' a.select2-choice')) {
    LOG.debug("doSelect2Type single");
    this.doSingleSelect2Type(cssSelector,value);
  } else if (selenium.isElementPresent(cssSelector + ' input.select2-input')) {
    LOG.debug("doSelect2Type multiple");
    this.doMultipleSelect2Type(cssSelector,value);
  } else {
    LOG.debug("doSelect2Type null");
    throw new SeleniumError("Select2 element not found : " + cssSelector);
  }
}

Selenium.prototype.doSingleSelect2Type = function(cssSelector,value) {
  var linkCssLocator = cssSelector + " a.select2-choice";
  this.doClickAt(linkCssLocator);
}

Selenium.prototype.doMultipleSelect2Type = function(cssSelector,value) {
  var inputCssSelector = cssSelector + " input.select2-input";
  this.doTypeKeys(inputCssSelector, value);
  this.doTypeKeys(inputCssSelector, value);
}

Selenium.prototype.doWaitForSelect2 = function(timeout) {
  return Selenium.decorateFunctionWithTimeout(function() {
    if (selenium.browserbot.findElementOrNull('css=.select2-result-selectable') == null) {
       LOG.debug("doWaitForSelect wait");
          return false;
    }
    LOG.info("doWaitForSelect found");
    return true;
  }, timeout);
}

/**
 * Screenshots.
 */
Selenium.prototype.doTakeScreenShot = function() {
  try {
    var file = Components.classes['@mozilla.org/file/local;1'].createInstance(Components.interfaces.nsILocalFile);
    file.initWithPath(outDir);
    var filePrefix = "screenshot";
    if (storedVars['currentTestCase'] && storedVars['currentTestCase'].length > 0) {
      filePrefix = storedVars['currentTestCase'];
    }
    var timestamp = new Date().getTime();
    file.append(filePrefix + timestamp + ".png");
    LOG.info("TakeScreenShot in " + file.path);
    this.doCaptureEntirePageScreenshot(file.path);
  } catch(e) {
    LOG.error("TakeScreenShot error" + e);
  }
};

Selenium.decorateFunctionWithTimeout = function(f, timeout, callback) {
  if (f == null) {
      return null;
  }

  var timeoutTime = getTimeoutTime(timeout);

  return function() {
      if (new Date().getTime() > timeoutTime) {
          if (callback != null) {
               callback();
          }
          selenium.doTakeScreenShot();
          throw new SeleniumError("Timed out after " + timeout + "ms");
      }
      return f();
  };
};


Selenium.prototype.doOriginalOpen = Selenium.prototype.doOpen;

Selenium.prototype.doOpen = function(url, ignoreResponseCode) {
 if (url) {
   var split = url.split("message=----- Selenium");
   if (split.length == 2) {
     storedVars['currentTestCase'] = split[1].replace(/^\s+|\s+$/g, '');
   }
 }
 return this.doOriginalOpen(url, ignoreResponseCode);
};
